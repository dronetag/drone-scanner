import 'package:flutter_opendroneid/flutter_opendroneid.dart';
import 'package:flutter_opendroneid/models/constants.dart';
import 'package:flutter_opendroneid/models/message_container.dart';

import '../models/message_container_authenticity_status.dart';
import '../services/location_service.dart';
import 'utils.dart';

class MessageContainerAuthenticator {
  final LocationService locationService;

  /// Detectors that contribute to final score.
  late final detectors = [
    MacAddressSpooferDetector(),
    LocationTimestampSpooferDetector(),
    AuthAndSystemTimestampSpooferDetector(),
    AuthDataSpooferDetector(),
    BasicIdSpooferDetector(),
    OperatorIdSpooferDetector(),
    LocationMessageSpooferDetector(),
    SelfIdSpooferDetector(),
    SystemDataSpooferDetector(),
    LocationSpooferDetector(locationService: locationService),
  ];

  MessageContainerAuthenticator({required this.locationService});

  /// Check contents of message container using [detectors].
  /// Check if messages contain values used in RemoteIDSpoofer.
  /// Each detector returns probability that data were spoofed.
  /// Sum up the probabilities and make final decision.
  /// Convert score into [MessageContainerAuthenticityStatus]
  /// according to interval:
  ///   < max/2 - untrusted
  ///   max/2, max/4*3 - suspicious
  ///   > max/4*3 - counterfeit.
  MessageContainerAuthenticityStatus determineAuthenticityStatus(
      MessageContainer container) {
    var score = 0.0;

    for (var element in detectors) {
      score += element.calculateSpoofedProbability(container);
    }

    return _scoreToStatus(score);
  }

  MessageContainerAuthenticityStatus _scoreToStatus(double score) {
    final maxScore = detectors.length;

    // if nothing can be decided, score is exactly half, when score is bigger
    // than half, at least one detector noticed suspisious data.
    // Score bellow 1/4 is considered verified.
    final untrustedScore = maxScore * 0.25;
    final noSuspisionScore = maxScore * 0.5;
    final counterfeitScore = maxScore * 0.75;

    if (score <= untrustedScore) {
      return MessageContainerAuthenticityStatus.verified;
    }
    if (score <= noSuspisionScore) {
      return MessageContainerAuthenticityStatus.untrusted;
    }
    if (score <= counterfeitScore) {
      return MessageContainerAuthenticityStatus.suspicious;
    }
    return MessageContainerAuthenticityStatus.counterfeit;
  }
}

abstract class SpooferDetector {
  const SpooferDetector();

  /// Return a probability that data are spoofed.
  ///   0 -> data are real
  /// 0.5 -> cannot decide
  ///   1 -> data are counterfeit
  double calculateSpoofedProbability(MessageContainer container);
}

class MacAddressSpooferDetector implements SpooferDetector {
  // MAC addresses generated by RemoteIDSpoofer always start with a zero
  // if starts with 0, still doesn't have to be spoofed
  @override
  double calculateSpoofedProbability(MessageContainer container) =>
      container.macAddress.startsWith('0') ? 0.75 : 0;
}

/// Compare received location timestamps with system time.
class LocationTimestampSpooferDetector implements SpooferDetector {
  // time difference thresholds in seconds
  static const suspiciousTimeDifference = 10;
  static const counterfeitTimeDifference = 60;

  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final locTimestamp = container.locationMessage?.timestamp;

    if (locTimestamp == null) return 0.5;

    final currentTimestamp = DateTime.now().toLocal();

    // subtract last full hour from current timestamp to get duration passed
    // from the last full hour
    final currentTimestampDurationSinceLastHour = currentTimestamp.difference(
      DateTime(currentTimestamp.year, currentTimestamp.month,
          currentTimestamp.day, currentTimestamp.hour),
    );

    // calculate absulute difference in seconds
    final locTimestampDifference = ((locTimestamp.inMilliseconds -
                currentTimestampDurationSinceLastHour.inMilliseconds) /
            1000)
        .abs();

    // if time difference is small, data can be still spoofed because spoofer
    // could be started at time that matches system timestamp but probability
    // is small
    if (locTimestampDifference < suspiciousTimeDifference) {
      return 0.1;
    } else if (locTimestampDifference < counterfeitTimeDifference) {
      return 0.75;
    }
    // big difference btw location and system timestamp means data are spoofed
    return 1;
  }
}

/// RemoteIDSpoofer starts counting time from known timestamp.
/// If received timestamp is in short interval after that timestamp,
/// data are probably spoofed.
class AuthAndSystemTimestampSpooferDetector implements SpooferDetector {
  static final spooferTimestamp = DateTime(2022, 11, 16, 10);
  static const maxUptime = Duration(days: 10);

  bool _isNearSpooferTimestamp(DateTime timestamp) =>
      timestamp.isAfter(spooferTimestamp) &&
      timestamp.isBefore(spooferTimestamp.add(maxUptime));

  // returns true if any of timestamps within the interval
  // (spooferTimestamp, spooferTimestamp + maxUptime).
  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final authTimestamp = container.authenticationMessage?.timestamp;
    final systemTimestamp = container.systemDataMessage?.timestamp;

    if (authTimestamp == null && systemTimestamp == null) return 0.5;

    return (authTimestamp != null && _isNearSpooferTimestamp(authTimestamp)) ||
            systemTimestamp != null && _isNearSpooferTimestamp(systemTimestamp)
        ? 1
        : 0;
  }
}

/// Following detectors check the contents of messages and compare them with
/// known values used in RemoteIDSpoofer.
class AuthDataSpooferDetector implements SpooferDetector {
  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final message = container.authenticationMessage;
    // message not received, cannot decide
    if (message == null) return 0.5;

    // if len and type are not exactly the same as the values used
    // by RemoteIDSpoofer, data are not spoofed
    if (message.authData.authData.length != MAX_AUTH_DATA_PAGES ||
        message.authType != AuthType.none) return 0.1;

    // auth data in RemoteIDSpoofer contain indexes
    for (var index = 0; index < message.authData.authData.length; index++) {
      if (message.authData.authData[index] != index) return 0.2;
    }
    return 0.8;
  }
}

class BasicIdSpooferDetector implements SpooferDetector {
  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final messages = container.basicIdMessages;

    if (messages == null || messages.isEmpty) return 0.5;

    // data from RemoteIDSpoofer always have 1 basic id with types set to .none
    return (messages.length == 1 &&
            messages.values.first.uaType == UAType.none &&
            messages.values.first.uasID.type == IDType.none)
        ? 0.8
        : 0.2;
  }
}

class OperatorIdSpooferDetector implements SpooferDetector {
  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final message = container.operatorIdMessage;
    // message not received, cannot decide
    if (message == null) return 0.5;

    // data in RemoteIDSpoofer have 16 random chars in Operator ID,
    // [OperatorIDTypeOperatorID] type and len 16
    if (message.operatorIDType is! OperatorIDTypeOperatorID ||
        message.operatorID.length != 16) return 0.3;
    // check that country code cantains only capital letters
    // if not, data are spoofed
    final countryCode = message.operatorID.substring(0, 3);
    if (countryCode != countryCode.toUpperCase()) return 0.9;
    // country code contains capital letters,
    // data can still be spoofed
    return 0.25;
  }
}

class LocationMessageSpooferDetector implements SpooferDetector {
  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final message = container.locationMessage;
    // message not received, cannot decide
    if (message == null) return 0.5;

    // spoofed if all values exactly match the values used in RemoteIDSpoofer
    final spoofed = message.status == OperationalStatus.none &&
        (message.verticalSpeed == null ||
            message.verticalSpeed == INV_SPEED_V) &&
        message.heightType == HeightType.aboveTakeoff &&
        message.horizontalAccuracy == HorizontalAccuracy.meters_10 &&
        message.verticalAccuracy == VerticalAccuracy.meters_10 &&
        message.baroAltitudeAccuracy == VerticalAccuracy.meters_10 &&
        message.speedAccuracy == SpeedAccuracy.meterPerSecond_10 &&
        // spoofed data have acc 1.5
        message.timestampAccuracy
                ?.compareTo(const Duration(milliseconds: 1500)) ==
            0;
    return spoofed ? 1 : 0.2;
  }
}

class SelfIdSpooferDetector implements SpooferDetector {
  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final message = container.selfIdMessage;
    // message not received, cannot decide
    if (message == null) return 0.5;

    // spoofed if description and it's type are same as in RemoteIDSpoofer
    return message.descriptionType is DescriptionTypeText &&
            message.description == "Recreational"
        ? 1
        : 0.2;
  }
}

class SystemDataSpooferDetector implements SpooferDetector {
  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final message = container.systemDataMessage;
    // message not received, cannot decide
    if (message == null) return 0.5;

    // spoofed if all values exactly match the values used in RemoteIDSpoofer
    final spoofed = message.operatorLocationType ==
            OperatorLocationType.takeOff &&
        message.uaClassification is UAClassificationEurope &&
        (message.uaClassification as UAClassificationEurope).uaCategoryEurope ==
            UACategoryEurope.EUOpen &&
        (message.uaClassification as UAClassificationEurope).uaClassEurope ==
            UAClassEurope.EUClass_4 &&
        message.areaCount == 1 &&
        message.areaRadius == 500 &&
        message.areaCeiling == null &&
        message.areaFloor == null;
    return spoofed ? 1 : 0.2;
  }
}

/// [LocationSpooferDetector] compares location of detected aircraft with
/// phone location.
class LocationSpooferDetector implements SpooferDetector {
  // distance thresholds in meters
  static const suspiciousDistance = 3000;
  static const counterfeitDistance = 10000;

  LocationService locationService;

  LocationSpooferDetector({required this.locationService});

  @override
  double calculateSpoofedProbability(MessageContainer container) {
    final phoneLocation = locationService.lastLocation;
    final aircraftLocation = container.locationMessage?.location;

    // when one of locations if null, detector cannot decide
    if (phoneLocation == null || aircraftLocation == null) return 0.5;

    // calc distance and convert to meters
    final distance = calculateDistance(
            phoneLocation.latitude,
            phoneLocation.longitude,
            aircraftLocation.latitude,
            aircraftLocation.longitude) *
        1000;

    // if distance is shorter than suspicious threshold,
    // there is still some change that data are spoofed.
    // Location is configurable in RemoteIDSpoofer.
    if (distance < suspiciousDistance) {
      return 0.2;
    } else if (distance < counterfeitDistance) {
      return 0.75;
    }
    // distance bigger than counterfeitDistance, spoofed for sure
    return 1;
  }
}
